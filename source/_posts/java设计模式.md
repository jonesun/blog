---
title: java设计模式
date: 2020-08-11 13:44:00
categories: [java, 设计模式] 
tags: [java, 设计模式]
top: 100
---

> 设计模式是为了可扩展性，不要为了使用设计模式而使用

# 概念

设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。

* 创建型模式: 创建型模式关注点是**如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换**，共五种：[工厂方法模式FactoryMethod](/2020/10/27/java设计模式-工厂方法模式)、[抽象工厂模式AbstractFactory](/2020/10/27/java设计模式-抽象工厂模式)、单例模式Singleton、建造者模式Builder、原型模式Prototype。
* 结构型模式: 结构型模式主要涉及**如何组合各种对象以便获得更好、更灵活的结构**，共七种：[适配器模式Adapter](/2020/10/28/java设计模式-适配器模式)、[装饰器模式Decorator](/2020/10/29/java设计模式-装饰器模式)、[代理模式Proxy](/2020/07/16/java设计模式-代理模式)、[外观模式Facade](/2020/10/30/java设计模式-外观模式)、[桥接模式Bridge](/2020/10/30/java设计模式-桥接模式)、[组合模式Composite](/2020/11/02/java设计模式-组合模式)、[享元模式Flyweight](/2020/11/02/java设计模式-享元模式)。
* 行为型模式: 行为型模式主要涉及算法和对象间的职责分配。这些设计模式是特别侧重于对象之间的通信，**通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务**，共十一种：[策略模式Strategy](/2020/11/03/java设计模式-策略模式)、[模板方法模式TemplateMethod](/2020/11/03/java设计模式-模板方法模式)、[观察者模式Observer](/2020/11/03/java设计模式-观察者模式)、迭代器模式Iterator、[责任链模式](/2020/09/27/java设计模式-责任链模式)、[命令模式Command](/2020/11/03/java设计模式-命令模式)、[备忘录模式Memento](/2020/11/05/java设计模式-备忘录模式)、[状态模式State](/2020/11/05/java设计模式-状态模式)、[访问者模式Visitor](/2020/11/05/java设计模式-访问者模式)、[中介者模式Mediator](/2020/11/05/java设计模式-中介者模式)、解释器模式Interpreter。

> 见名思意, 代码中出现了类名存在如Adapter、Factory、Decorator等，可以联想到对应的设计模式，无论自己编写还是查阅他人代码
  
设计模式需要满足：
* 开闭原则: 软件应该对扩展开放，而对修改关闭。这里的意思是在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的
* 里氏替换原则: 即如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行

**特别感谢[廖雪峰老师的文章](https://www.liaoxuefeng.com/wiki/1252599548343744/1264742167474528)推荐学习!**

[另一个大佬](https://www.iteye.com/blog/zz563143188-1847029)

```
//todo
```

# 模式间的区别

## 装饰器模式VS代理模式

**装饰模式** 注重对对象功能的扩展，它不关心外界如何调用，只注重对对象功能的加强，**装饰后还是对象本身**

**代理模式** 注重对对象某一功能的流程把控和辅助。它可以控制对象做某些事，偏重因自己无法完成或自己无需关心，需要他人干涉事件流程，更多的是对对象的控制，重心是为了**借用对象的功能完成某一流程**，而非对象功能如何。

## 建造者模式VS桥接模式

最终目标都是构造大对象

**建造者模式**：初始化每个变量的时候，都返回了最终的对象，就是你可以**不完全链式的点完所有变量**，亦可得到可使用的对象；每个成员变量在构造时是同层次的

**桥接模式**: 初始化时，**每个部分缺一不可**；每个成员变量的层级不同，使用最小的部件，逐层往上初始化直至整个对象，类似于用 发动机-> 引擎模块 ->  引擎模块 + 车壳（类比文中品牌）-> 完整的汽车 【一级连接一级，有点桥接的意思】

## 享元模式VS单例模式

* 享元设计模式是一个类有很多对象，而单例是一个类仅一个对象。

* 享元模式是为了节约内存空间，提升程序性能，而单例模式则主要是出于共享状态的目的。

## 工厂方法模式VS抽象工厂模式VS模板方法模式

* 简单工厂能把具体实现包装起来，让客户端真正达到面向接口编程 
* 工厂方法可以在高层进行编码，让服务端的产品线真正达到面向接口编程 
* 抽象工厂能聚合整个产品簇，让整个服务端的多个产品线真正达到面向接口编程 
* 模板方法同样是在高层进行编码，也同样是面向接口编程。 
  
但工厂方法及抽象工厂方法着重抽象的是产品，而模板方法着重抽象的是步骤。 
而我们通常会两者一起结合起来使用。
